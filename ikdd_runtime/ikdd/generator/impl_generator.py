
def _collect_entry_params(flow_steps):
    produced = set()
    params = []
    for step in flow_steps:
        inputs = step.get("input", []) or []
        for name in inputs:
            if name not in produced and name not in params:
                params.append(name)
        out = step.get("output", None)
        if out:
            produced.add(out)
    return params

def generate_code(tool: dict, knowledge_module) -> str:
    tool_spec = tool["tool"]
    func_name = tool_spec["name"]
    flow = tool_spec["flow"]
    id_map = knowledge_module.__id_map__
    snippet_map = knowledge_module.__snippet_map__

    lines = ["# Generated by IKDD Runtime v0.1", ""]

    # Emit knowledge snippets exactly as provided (dedented already)
    emitted = set()
    for step in flow:
        use_id = step["step"]
        if use_id in emitted:
            continue
        snippet = snippet_map.get(use_id)
        if not snippet:
            raise RuntimeError(f"Missing snippet for knowledge id: {use_id}")
        lines.append(snippet.rstrip())
        lines.append("")
        emitted.add(use_id)

    entry_params = _collect_entry_params(flow)
    signature = ", ".join(entry_params)

    lines.append(f"def {func_name}({signature}):")
    if not flow:
        lines.append("    pass")
        return "\n".join(lines) + "\n"

    for idx, step in enumerate(flow):
        use_id = step["step"]
        func_name_k = id_map[use_id]
        inputs = step.get("input", []) or []
        output = step.get("output", None)
        arglist = ", ".join(inputs)
        if output:
            lines.append(f"    {output} = {func_name_k}({arglist})")
        else:
            lines.append(f"    {func_name_k}({arglist})")

    # Return last output if exists
    for step in reversed(flow):
        if step.get("output", None):
            lines.append(f"    return {step['output']}")
            break

    return "\n".join(lines) + "\n"
