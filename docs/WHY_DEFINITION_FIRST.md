# WHY_DEFINITION_FIRST.md

**なぜ IKDD は「定義を先に書く」のか？（Definition-First の意義）**

---

## 0. 結論（最初に）

> **コードは生成物。定義が一次情報（Single Source of Truth）。**

IKDD の目的は、

> **「コードを書く」ではなく「変更に強い構造を作る」こと。**

短期では実装主導（Implementation-first）が速い。
しかし、

> **変更・再利用・引き継ぎ・複数ターゲット生成** が入ると
> 定義が一次情報である「Definition-first」が圧倒的に強くなる。

---

## 1. 現実世界の課題

ソフトウェア開発では、**コードの寿命より変更の寿命が長い。**

| フェーズ | 経験的に起こること          |
| ---- | ------------------ |
| 実装   | 必要なコードはすぐ書ける       |
| 保守   | 要件変更が発生する          |
| 拡張   | コードが複雑化し、意図が読めなくなる |
| 引継   | 「この実装、なんでこうしてる？」問題 |

要するに、

> **"書く"より "直す" と "説明する"方が難しい。**

---

## 2. 実装主導（Implementation-first）の特徴

```
仕様 → コード
```

* 意図がコードに埋もれる
* コードを読まなければ理解できない
* 修正が波及する（バタフライ効果）
* 生成AIを使っても **コードは一度きりの成果物**

> **実装主導はスピードは速いが、蓄積ができない。**

---

## 3. Definition-first（IKDD）のアプローチ

```
意図 / 目的 / 制約（must / forbidden / keep）
        ↓
      定義
        ↓
    行動（生成 / 実装 / 実行）
```

* **意図を定義として残す**
* 実装は「定義の結果として生成」される
* 変更は「定義の変更」として扱える

> **定義を変えれば、すべてが再生成される。**

---

## 4. 何が嬉しいのか（価値）

### ✅ 一貫性

定義 = Single Source of Truth
複数実装への反映がズレない。

例：

* CLI / API / プラグイン / DCC ツール 等 **複数ターゲット生成**

---

### ✅ トレーサビリティ

「この動作はどの must / forbidden / keep によるもの？」が追跡できる。

---

### ✅ 再利用性

定義（tool / knowledge / constraint）が独立して再利用できる。

---

### ✅ 認知負荷の低減

コード全体を読まなくていい。
**「意図を見る」だけで把握できる。**

---

## 5. Definition-first が勝つ場面

| ケース         | Implementation-first | Definition-first |
| ----------- | -------------------- | ---------------- |
| 単発 / 短命     | ✅ 最速                 | ❌ 過剰             |
| 継続保守 / 要件変更 | ❌ 重い                 | ✅ 変更が局所          |
| 複数実装 / 横展開  | ❌ 同期が地獄              | ✅ 定義1つで全展開       |
| 他者への引き継ぎ    | ❌ コード読解              | ✅ 定義を読むだけ        |

> **長期戦 / 多面展開 / 引き継ぎ が前提の場合、Definition-first が勝つ。**

---

## 6. IKDD のミッション

> **コードではなく「意図」を資産化する。
> 人による実装ではなく、定義に基づく自動生成に寄せる。**

---

## 7. IKDD Runtime が保証すること

| Runtime が担保するもの | 意味                              |
| --------------- | ------------------------------- |
| 再現性             | 同じ定義 → 同じ生成結果                   |
| 一貫性             | 複数の実装に同期                        |
| トレーサビリティ        | 「どの定義が効いているか」がわかる               |
| 検証性 (v0.3〜)     | Lint / Type / Constraint / Test |

---

## 8. スローガン

```
コードは消費するもの。
定義は残すもの。
```

---

## 9. まとめ

|        | 実装主導     | Definition-first（IKDD） |
| ------ | -------- | ---------------------- |
| 目的     | 動くコードを書く | **意図を残す / 資産化**        |
| 価値     | 一時的      | 永続的                    |
| アウトプット | ソースコード   | **定義（←一次情報）**          |
| 人の役割   | 書く人      | **意図を定義する人**           |

---
